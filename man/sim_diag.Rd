% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qp1qc_solver.R
\name{sim_diag}
\alias{sim_diag}
\title{Simultaneously diagonalize two symmetric matrices (1 being positive definite)}
\usage{
sim_diag(M1, M2, eigenM1 = NULL, eigenM2 = NULL, tol = 10^-4,
  return_diags = FALSE)
}
\arguments{
\item{M1}{a positive definite symmetric matrix}

\item{M2}{a symmetric matrix}

\item{eigenM1}{(optional) the value of \code{eigen(M1)}, if precomputed and available}

\item{eigenM2}{(optional) the value of \code{eigen(M2)}, if precomputed and available}

\item{tol}{used for error checks}

\item{return_diags}{should only the diagonalizing matrix be returned.}
}
\value{
If \code{return_diags = FALSE}, the matrix Q is returned. Otherwise, a list with the following elements is returned
\itemize{
		\item{diagonalizer}{ - the matrix Q}
	\item{inverse_diagonalizer}{ - the inverse of Q}
	\item{M1diag}{ - the diagonal elements of (Q' M1 Q), which will all be ones}
	\item{M2diag}{ - the diagonal elements of (Q' M2 Q)}
}
}
\description{
Simultaneously diagonalize two symmetric matrices (1 being positive definite)
}
\details{
This function determines an invertible matrix Q such that (Q' M1 Q) is an identity matrix, and (Q' M2 Q) is diagonal, where Q' denotes the transpose of Q. Note, Q is not necessarily orthonormal or symmetric.
}
\examples{
p <- 5
M1 <- diag(p) + crossprod(matrix(rnorm(p^2),p,p))
M1[1,] <- M1[,1] <- 0
M2 <- diag(p)+2
sdb <- sim_diag(M1=M1,M2=M2,tol=10^-10,return_diags=TRUE)
Q <- sdb$diagonalizer
QM1Q <- t(Q) \%*\% M1 \%*\% Q
QM2Q <- t(Q) \%*\% M2 \%*\% Q
range(QM1Q -diag(sdb$M1diag))
range(QM2Q -diag(sdb$M2diag))
range(Q \%*\% sdb$inverse_diagonalizer - diag(p))
range(sdb$inverse_diagonalizer \%*\% Q - diag(p))
}
